'use strict';Object.defineProperty(exports, '__esModule', { value: true }); // istanbul ignore next
var _createClass = (function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};})(); // istanbul ignore next
var _get = function get(_x, _x2, _x3) {var _again = true;_function: while (_again) {var object = _x, property = _x2, receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {var parent = Object.getPrototypeOf(object);if (parent === null) {return undefined;} else {_x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;}} else if ('value' in desc) {return desc.value;} else {var getter = desc.get;if (getter === undefined) {return undefined;}return getter.call(receiver);}}}; // istanbul ignore next
function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };} // istanbul ignore next
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError('Cannot call a class as a function');}} // istanbul ignore next
function _inherits(subClass, superClass) {if (typeof superClass !== 'function' && superClass !== null) {throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) subClass.__proto__ = superClass;}var _events = require('events');var _app_dispatcher = require('../app_dispatcher');var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);var _constantsWeapon_constants = require('../constants/weapon_constants');var _constantsWeapon_constants2 = _interopRequireDefault(_constantsWeapon_constants);var CHANGE = 'WEAPON_UPDATED';
var data = { 
  last_id: 0, 
  equipped_weapons: {} };


// This is the 'ticker' that goes through all weapons that is currently in cooldown .
// It it reduces the cooldown counter for each weapon and reactivates them when clock turns 0
var cooldown_ticker = setInterval(function () {

  for (var equipped_weapon_id in data.equipped_weapons) {
    var equipped_weapon = data.equipped_weapons[equipped_weapon_id];
    if (equipped_weapon.is_disabled === false) {continue;}

    if (equipped_weapon.cooldown_time_remaining < 0) {
      equipped_weapon.cooldown_time_remaining = 0;
      equipped_weapon.is_disabled = false;} else 
    {
      equipped_weapon.cooldown_time_remaining = +(equipped_weapon.cooldown_time_remaining - .1).toFixed(2);}}



  _WeaponStore.emit(CHANGE);}, 
100);

/**
 * Equip a weapon
 * @param {string} id
 */
var equip = function equip(weapon_props) {
  var equipped_weapon = Object.assign({ 
    id: (+new Date() + Math.floor(Math.random() * 999999)).toString(36), 
    weapon_groups: { grp1: true, grp2: false, grp3: false, grp4: false, grp5: false, grp6: false }, 
    cooldown_time_remaining: 0, 
    is_disabled: false }, 
  weapon_props);
  data.equipped_weapons[equipped_weapon.id] = equipped_weapon;};


/**
 * Delete a weapon
 * @param {string} id
 */
var destroy = function destroy(id) {
  delete data.equipped_weapons[id];};


/**
 * Unequips all weapons
 */

var strip_all = function strip_all() {
  console.log('callecalledd');
  data.equipped_weapons = [];};


/** Toggle the weapon group of an equipped weapon
 * @param {string} equipped_weapon_id - ID of the weapon
 * @param {string} group_id - ID of the weapon_group (1, 2, 3. not grp1, grp2)
 */
var toggle_equipped_weapon_group = function toggle_equipped_weapon_group(equipped_weapon_id, group_id) {
  var group_id = 'grp' + group_id;
  var current_value = data.equipped_weapons[equipped_weapon_id].weapon_groups[group_id];
  data.equipped_weapons[equipped_weapon_id].weapon_groups[group_id] = !current_value;};


/**
 * emits a "WEAPON_DID_ALPHA" that causes equipped weapon components subscribed to the action to fire
 * and sets the damage.data.last to the total of all weapons fired
 */
var alpha_strike = function alpha_strike() {
  _WeaponStore.emit(_constantsWeapon_constants2['default'].WEAPON_WILL_GROUP_FIRE);
  _WeaponStore.emit(_constantsWeapon_constants2['default'].WEAPON_DID_ALPHA);};


/**
 * emits a "WEAPON_GROUP_FIRE" that causes equipped weapon under a given group_id to fire
 * and sets the damage.data.last to the total of all weapons fired
 */
var group_fire = function group_fire(group_id) {
  _WeaponStore.emit(_constantsWeapon_constants2['default'].WEAPON_WILL_GROUP_FIRE);
  _WeaponStore.emit(_constantsWeapon_constants2['default'].WEAPON_DID_GROUP_FIRE, group_id);};


/**
 * starts the cooldown process of the equipped weapon, disabling the weapon and, setting cooldown time.
 * @param {string} equipped_weapon_id
 */
var cooldown_weapon = function cooldown_weapon(equipped_weapon_id) {
  // No-oP if still on cooldown
  if (data.equipped_weapons[equipped_weapon_id].is_disabled === true) {return;}

  // Disable Weapon
  data.equipped_weapons[equipped_weapon_id].is_disabled = true;

  // Set Cooldown Timer to the weapon's cooldown time
  data.equipped_weapons[equipped_weapon_id].cooldown_time_remaining = +data.equipped_weapons[equipped_weapon_id].cooldown_time.toFixed(2);};var 



WeaponStore = (function (_EventEmitter) {function WeaponStore() {_classCallCheck(this, WeaponStore);_get(Object.getPrototypeOf(WeaponStore.prototype), 'constructor', this).apply(this, arguments);}_inherits(WeaponStore, _EventEmitter);_createClass(WeaponStore, [{ key: 'get_new_data', 

    // move this to store base class
    value: function get_new_data() {
      return data;} }, { key: 'emitChange', 


    // move this to store base class
    value: function emitChange() {
      this.emit(CHANGE);} }, { key: 'addChangeListener', 


    // move this to store base class
    value: function addChangeListener(callback) {
      this.on(CHANGE, callback);} }, { key: 'removeChangeListener', 


    // move this to store base class
    value: function removeChangeListener(callback) {
      this.removeListener(CHANGE, callback);} }]);return WeaponStore;})(_events.EventEmitter);





var _WeaponStore = new WeaponStore();

_WeaponStore.setMaxListeners(0);exports['default'] = 

_WeaponStore;

_WeaponStore.dispatch_token = _app_dispatcher2['default'].register(function (payload) {
  var action_type = payload.action_type;
  switch (action_type) {
    case _constantsWeapon_constants2['default'].WEAPON_EQUIP:
      equip(payload.weapon_props);
      _WeaponStore.emit(CHANGE);
      break;
    case _constantsWeapon_constants2['default'].WEAPON_UNEQUIP:
      destroy(payload.index);
      _WeaponStore.emit(CHANGE);
      break;
    case _constantsWeapon_constants2['default'].WEAPON_ALPHA:
      setTimeout(alpha_strike);
      break;
    case _constantsWeapon_constants2['default'].WEAPON_GROUP_FIRE:
      // setTimeout(group_fireupayload.group_id))
      setTimeout(function () {group_fire(payload.group_id);});
      _WeaponStore.emit(CHANGE);
      break;
    case _constantsWeapon_constants2['default'].WEAPON_TOGGLE_GROUP:
      toggle_equipped_weapon_group(payload.equipped_weapon_id, payload.group_id);
      _WeaponStore.emit(CHANGE);
      break;
    case _constantsWeapon_constants2['default'].WEAPON_COOLDOWN:
      cooldown_weapon(payload.equipped_weapon_id);
      _WeaponStore.emit(CHANGE);
      break;
    case _constantsWeapon_constants2['default'].WEAPON_STRIP_ALL:
      strip_all();
      _WeaponStore.emit(CHANGE);
      break;}});module.exports = exports['default'];